<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Cheng TAN</title>
        <description>Cheng TAN - Naizhengtan</description>
        <link>http://naizhengtan.github.io</link>
        <link>http://naizhengtan.github.io</link>
        <lastBuildDate>2017-11-30T20:37:43-05:00</lastBuildDate>
        <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title></title>
                <description>&lt;p&gt;This series of blogs are designed to explore the inner implementation and desgin of 
&lt;a href=&quot;hhvm.com&quot;&gt;hhvm&lt;/a&gt;, a PHP interpreter developed by Facebook. There are a set of topics
should be covered, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-15-inside-hhvm-value-system&quot; title=&quot;value system&quot;&gt;Value systems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-18-inside-hhvm-main-loop&quot; title=&quot;main loop&quot;&gt;Interpreter Architecture I: Main Loop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Interpreter Architecture II: Stack&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Interpreter Architecture III: Function Call&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-21-inside-hhvm-builtin-function&quot; title=&quot;buitin function&quot;&gt;Builtin Functions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;HHVM bytecode&lt;/li&gt;
  &lt;li&gt;Jit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HHVM is still in rapid developing, and the version I am working on is 3.6.0.
However, I believe the main design and implementation would remain the same.&lt;/p&gt;

&lt;h3 id=&quot;overview&quot;&gt;Overview&lt;/h3&gt;

&lt;p&gt;Function is a very important abstraction in any nowadays languages.
How to construct a function and how to call it should be known if
someone really want to understand the design of a language or its
implementation.&lt;/p&gt;

&lt;p&gt;For HHVM, there are three phase of a function call:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Push function frame&lt;/li&gt;
  &lt;li&gt;Push arguments&lt;/li&gt;
  &lt;li&gt;Call the function&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s see a concrete example to explore what’re these phases do.&lt;/p&gt;

&lt;h3 id=&quot;function-call-workflow&quot;&gt;Function Call Workflow&lt;/h3&gt;

&lt;p&gt;In order to fully understand how hhvm works on function calls,
let’s see the most naive example as usual. Here is a function-call
example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

function foo ($str) {
	echo &quot;foo is called with $str\n&quot;;
}

foo(&quot;hello!&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As always, let’s use &lt;code&gt;hhvm -vEval.DumpHhas=true &amp;lt;example.php&amp;gt;&lt;/code&gt;
command to translate the script into bytecodes. After the translation,
we will see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.main {
	FPushFuncD 1 &quot;foo&quot;
	String &quot;hello!&quot;
	FPassCE 0
	FCall 1
	PopR
	Int 1
	RetC
 }

.function [mayusevv] foo($str) {
	String &quot;foo is called with &quot;
	CGetL $str
	Concat
	String &quot;\n&quot;
	Concat
	Print
	PopC
	Null
	RetC
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;code&gt;foo&lt;/code&gt; is quite clear and easy to understand. 
It is &lt;code&gt;.function foo{...}&lt;/code&gt; in the bytecode. Basically, it
push literal string “foo is called with “ into the stack,
get the content in $str to the stack too, and concatenate them
for printing. At last, return Null as result (no one will take
this value actually).&lt;/p&gt;

&lt;p&gt;The key point is how can we, the interpreter, find and call
the function “foo”. If you see &lt;code&gt;.main{...}&lt;/code&gt; carefully, there
are four basic steps which can be mapped to the phases we talked
in the overview section:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Push function frame  -&amp;gt;  FPushFuncD&lt;/li&gt;
  &lt;li&gt;Push arguments  -&amp;gt;  FPassCE&lt;/li&gt;
  &lt;li&gt;Call the function  -&amp;gt;  FCall&lt;/li&gt;
  &lt;li&gt;Consume the result  -&amp;gt;  PopR&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the following sections, I will explain them in detail.
Yet, the data structure as well as the mechanism is too both
mass and mess to be clear, so I probably won’t show the bloody
details of everythin.&lt;/p&gt;

&lt;h3 id=&quot;fpushxxx&quot;&gt;FPushXXX&lt;/h3&gt;

&lt;p&gt;There are several different FPushXXX bytecode, such as 
FPushFunc, FpushFuncObjMethod, FPushClsMethod and so on.
Ignoring whether they issue a warning or wheter using the stack
of literal string as function name, the FPushXXX bytecode can
be classified into five groups:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pure function calls (FPushFunc)&lt;/li&gt;
  &lt;li&gt;Object method call  (FPushObjMethod)&lt;/li&gt;
  &lt;li&gt;Class method call   (FPushClsMethod)&lt;/li&gt;
  &lt;li&gt;Constructor call    (FPushCtor)&lt;/li&gt;
  &lt;li&gt;Callable call       (FPushCuf)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The name of the classification is quite self-explaining. In our
most naive example, the program defines a pure function, which
does not belong to any class, and calls it. So we met the 
instruction &lt;code&gt;FPushFuncD&lt;/code&gt;.
Here is the implementaion of the instruction &lt;code&gt;FPushFuncD&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTBLD_INLINE void iopFPushFuncD(IOP_ARGS) {
	pc++;
	// (1) get the number of arguments
	auto numArgs = decode_iva(pc);
	
	// (2) find the calling function
	auto id = decode&amp;lt;Id&amp;gt;(pc);
	const NamedEntityPair nep =
 		vmfp()-&amp;gt;m_func-&amp;gt;unit()-&amp;gt;lookupNamedEntityPairId(id);
 	Func* func = Unit::loadFunc(nep.second, nep.first);
 	
 	// (3) construct the function frame
	ActRec* ar = fPushFuncImpl(func, numArgs);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The macro is defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define IOP_ARGS   PC&amp;amp; pc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(1) &lt;strong&gt;Get the number of arguments&lt;/strong&gt;: This line of code fetches the number of
arguments from the bytecode. From the bytecode &lt;code&gt;FPushFuncD 1 &quot;foo&quot;&lt;/code&gt;, interpreter
can know how many arguments are there.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;Find the calling function&lt;/strong&gt;: This process is pretty similar or basically
the same with the &lt;a href=&quot;/2017/11/30/2015-7-21-inside-hhvm-builtin-function&quot; title=&quot;buitin function&quot;&gt;buitin function&lt;/a&gt; searching. Please refer that for more
information.&lt;/p&gt;

&lt;p&gt;(3) &lt;strong&gt;Construct the function frame&lt;/strong&gt;: 
This is the key function of the bytecode &lt;code&gt;FPushFuncD&lt;/code&gt;. By taking one step further,
the implementation of &lt;code&gt;fPushFuncImpl(...)&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTBLD_INLINE ActRec* fPushFuncImpl(const Func* func, int numArgs) {
	ActRec* ar = vmStack().allocA();
	ar-&amp;gt;m_func = func;  
	ar-&amp;gt;initNumArgs(numArgs);
	ar-&amp;gt;setVarEnv(nullptr);
	return ar;
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The previous function allocate an &lt;code&gt;ActRec&lt;/code&gt; on the stack and set the attributes
of the structure with function pointer and number of arguments. &lt;code&gt;ActRec&lt;/code&gt; should
be introduced in chapter “Stack” which I haven’t finished yet. In short, &lt;code&gt;ActRec&lt;/code&gt;
is a representation of function call record with all different kinds of information
related to such function call.&lt;/p&gt;

&lt;h3 id=&quot;fpassxxx&quot;&gt;FPassXXX&lt;/h3&gt;

&lt;p&gt;These instructions are trying to pass the arguments for the function, and basically
what it does is checking if the argument on stack is appropriate. For example,
&lt;code&gt;FPassCE&lt;/code&gt; will issue an error if the argument is not satisfied.&lt;/p&gt;

&lt;h3 id=&quot;fcall&quot;&gt;FCall&lt;/h3&gt;

&lt;p&gt;There are series of FCall bytecodes for different purpose. Here I want to
emphasise two kinds of FCall:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Normal function call (FCall)&lt;/li&gt;
  &lt;li&gt;Builtin function call (FCallBuiltin)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Normal function call are calling to the php function which developer written;
while builtin function call are the invokations to the functions php interpreter
or runtime provides. If you want to know more, check &lt;a href=&quot;/2017/11/30/2015-7-21-inside-hhvm-builtin-function&quot; title=&quot;buitin function&quot;&gt;builtin function&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The core functionality of these series of instructions is take the arguments
passing through stack and jump to the entry of the function. This core task has
been implemented in function &lt;code&gt;doFCall(...)&lt;/code&gt; in file &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/bytecode.cpp&quot; title=&quot;main loop&quot;&gt;runtime/vm/bytecode.cpp&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is a simplified version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool doFCall(ActRec* ar, PC&amp;amp; pc) {
	prepareFuncEntry(ar, pc, StackArgsState::Untrimmed);
	vmpc() = pc;
	return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The inputs “ar” is the newly created &lt;code&gt;ActRec&lt;/code&gt; by &lt;code&gt;FPushFuncD&lt;/code&gt; and the “pc”
is current program counter. Inside function &lt;code&gt;prepareFuncEntry(...)&lt;/code&gt;, the pc will
be rewrote to the function’s entry point by the line &lt;code&gt;pc = func-&amp;gt;getEntry();&lt;/code&gt;.
After that, set the vmpc() to pc and return. The vmpc() is the program counter
for current thread:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inline const unsigned char*&amp;amp; vmpc() {
	return vmRegs().pc;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;popr&quot;&gt;PopR&lt;/h3&gt;

&lt;p&gt;The final stage is consume the result of the function.
For this example, the function &lt;code&gt;foo&lt;/code&gt; don’t have any result, so the
bytecode just pop whatever as the result.&lt;/p&gt;

&lt;p&gt;If function has a result and caller wants it, like &lt;code&gt;$result = foo()&lt;/code&gt;
there would be a snippet of byte code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
FCall 1
UnboxR
SetL $result
PopC
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return value will be placed on the top of the stack. And the return
variable which is $result in this case will be set to that value, then
pop the result.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To conclude, in this article, I have tried to give the readers a overview
of how HHVM invoke a function. It includes three stages which are (1) construct
and push the function frame, (2) pass the arguments and (3) jump to the function.&lt;/p&gt;

</description>
                <link>http://naizhengtan.github.io/2017/11/30/2015-8-1-inside-hhvm-function-call</link>
                <guid>http://naizhengtan.github.io/2017/11/30/2015-8-1-inside-hhvm-function-call</guid>
                <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        </item>

        <item>
                <title></title>
                <description>&lt;p&gt;Recently, I met a problem on deploying &lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/hotcrp/&quot; title=&quot;hotcrp&quot;&gt;HotCRP&lt;/a&gt; on Nginx+HHVM.
It seems that Nginx cannot redirect the URI correctly to HotCRP.
During the trouble shooting process, I was really annoying by the 
Nginx’s configuration and simple-but-not-complete blogs online.
So I’ve decided to structurally learn and write down the Nginx
config staff.&lt;/p&gt;

&lt;p&gt;This is the second blog about Nginx Configuration.
I will focus on the fastcgi configuration for php/hhvm
&lt;!---and a lit bit about reverse proxy---&gt;.
The config file on Ubuntu14.04 will be in “/etc/nginx/nginx.conf”. 
If you don’t know where your config file is, 
you can use &lt;code&gt;nginx -t&lt;/code&gt; to check it out.&lt;/p&gt;

&lt;p&gt;There probably will be one more blog talking about reverse proxy:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-22-web-nginx-config-I&quot; title=&quot;nginx I&quot;&gt;Web: Nginx Basic Configuration&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Web: Nginx FastCGI&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Web: Nginx Reverse Proxy&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-if-fastcgi&quot;&gt;What if FastCGI&lt;/h3&gt;

&lt;p&gt;As you can see “FastCGI” should be fast version of &lt;a href=&quot;https://en.wikipedia.org/wiki/Common_Gateway_Interface&quot; title=&quot;CGI&quot;&gt;CGI&lt;/a&gt;, which is
almost true. CGI is a very simple protocol which allows the webserver
to run some program in the old days when only the static pages are available.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CGI allows the owner of the Web server to designate a directory within 
the document collection as containing executable scripts (or binary files)
instead of pre-written pages; this is known as a CGI directory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FastCGI is the successor of CGI. It has solved two very important problem that
CGI involved: perforamnce and security.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;FastCGI’s main aim is to reduce the overhead associated with
interfacing the web server and CGI programs, allowing a server
to handle more web page requests at once.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FastCGI is also fairly simple protocol. In short, it connects two sides: webserver
and one program (php, ruby on rails and so on).
First, the webserver (nginx) sends
a series of key-value pairs which represents the request variables from user,
as well as some environment variables.
The program on the other side, which is usually a daemon, receives these pairs as
inputs and sends the result (usually is a html page) back to webserver. Finally,
the webserver reply user’s browser with such page.&lt;/p&gt;

&lt;h3 id=&quot;fastcgi-configuration&quot;&gt;FastCGI Configuration&lt;/h3&gt;

&lt;p&gt;As we mentioned in &lt;a href=&quot;/2017/11/30/2015-7-22-web-nginx-config-I&quot; title=&quot;nginx I&quot;&gt;previous blog&lt;/a&gt;, “location context” is where we usually
redirect one request to another folder. Same thing happens here. If we want to
run FastCGI protocol for a request, the first step is to set up which url will
redirect to the program running on another side of FastCGI.&lt;/p&gt;

&lt;p&gt;Let’s see an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ ^.*\.php$ {
  fastcgi_pass 127.0.0.1:9000;
  include fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example redirects all the requests ending with “.php” to the localhost
port 9000. And include the directives in file “fastcgi_params”.&lt;/p&gt;

&lt;p&gt;The following lines are the full contents from file “fastcgi_params”. I don’t know
where it comes from (is it a standard file for everyone?). It just happens appear
in my Nginx configuration folder. Yet, after I read it, I found it is a best practice
to place all the FastCGI configuration in a file and includes it each time you want
to use FastCGI protocol.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastcgi_param   QUERY_STRING            $query_string;
fastcgi_param   REQUEST_METHOD          $request_method;
fastcgi_param   CONTENT_TYPE            $content_type;
fastcgi_param   CONTENT_LENGTH          $content_length;
 
fastcgi_param   SCRIPT_FILENAME         $document_root$fastcgi_script_name;
fastcgi_param   SCRIPT_NAME             $fastcgi_script_name;
fastcgi_param   PATH_INFO               $fastcgi_path_info;
fastcgi_param   PATH_TRANSLATED		$document_root$fastcgi_path_info;
fastcgi_param   REQUEST_URI             $request_uri;
fastcgi_param   DOCUMENT_URI            $document_uri;
fastcgi_param   DOCUMENT_ROOT           $document_root;
fastcgi_param   SERVER_PROTOCOL         $server_protocol;
 
fastcgi_param   GATEWAY_INTERFACE       CGI/1.1;
fastcgi_param   SERVER_SOFTWARE         nginx/$nginx_version;
 
fastcgi_param   REMOTE_ADDR             $remote_addr;
fastcgi_param   REMOTE_PORT             $remote_port;
fastcgi_param   SERVER_ADDR             $server_addr;
fastcgi_param   SERVER_PORT             $server_port;
fastcgi_param   SERVER_NAME             $server_name;
 
fastcgi_param   HTTPS                   $https;
 
# PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param   REDIRECT_STATUS         200;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One important line to explain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastcgi_param   SCRIPT_FILENAME         $document_root$fastcgi_script_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SCRIPT_FILENAME decides which script you’re going to run.
And $document_root is a builtin variable which is your root folder for this location;
$fastcgi_script_name is another builtin varialbe which can be set by directive 
&lt;code&gt;fastcgi_index name;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;fastcgi-variables&quot;&gt;FastCGI Variables&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;$fastcgi_script_name&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;request URI or, if a URI ends with a slash, request URI with an index file 
name configured by the fastcgi_index directive appended to it. 
This variable can be used to set the SCRIPT_FILENAME and PATH_TRANSLATED 
parameters that determine the script name in PHP. 
For example, for the “/info/” request with the following directives
&lt;code&gt;fastcgi_index index.php;&lt;/code&gt;
&lt;code&gt;fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;&lt;/code&gt;
the SCRIPT_FILENAME parameter will be equal to “/home/www/scripts/php/info/index.php”.
When using the fastcgi_split_path_info directive, 
the $fastcgi_script_name variable equals the value of the 
first capture set by the directive.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;$fastcgi_path_info&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;the value of the second capture set by the fastcgi_split_path_info directive.
This variable can be used to set the PATH_INFO parameter.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;fastcgi-directives&quot;&gt;FastCGI Directives&lt;/h3&gt;

&lt;p&gt;In my opinion, there are four directives which are pretty important and very
common during your configuration. They are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_pass&quot; title=&quot;fastcgi_pass&quot;&gt;fastcgi_pass&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_param&quot; title=&quot;fastcgi_param&quot;&gt;fastcgi_param&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_split_path_info&quot; title=&quot;fastcgi_split_path_info&quot;&gt;fastcgi_split_path_info&lt;/a&gt;
&lt;!--- - [fastcgi_index][c8]---&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;fastcgi_pass&lt;/strong&gt; &lt;em&gt;address&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;This directive sets the address of a FastCGI server. 
It is like the entrance symbol to show where the other side of FastCGI
is listening on. The address can be a network port like “localhost:9000”.
It can also be a local socket, like Unix-domain socket.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fastcgi_param&lt;/strong&gt; &lt;em&gt;parameter value&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;This is probably the most popular directive
for FastCGI context.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sets a parameter that should be passed to the FastCGI server. 
The value can contain text, variables, and their combination. 
These directives are inherited from the previous level if and 
only if there are no fastcgi_param directives defined on the current level.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;fastcgi_split_path_info&lt;/strong&gt; &lt;em&gt;regex&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;This is a pretty useful directive when
you want to redirect all the request to a same script, usually it’s index.php.
Using it, you can have one main entrance (index.php) with the argument 
“PATH_INFO” to further decide what to do.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Defines a regular expression that captures a value for the 
$fastcgi_path_info variable. 
The regular expression should have two captures: the first 
becomes a value of the $fastcgi_script_name variable,
the second becomes a value of the $fastcgi_path_info variable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This line in “fastcgi_params” will assgin $fastcgi_path_info to PATH_INFO
environment variable in the program.
&lt;code&gt;fastcgi_param   PATH_INFO               $fastcgi_path_info;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;location-regular-expression&quot;&gt;Location Regular Expression&lt;/h3&gt;

&lt;p&gt;What the hell is Nginx’s regular expression’s standard?
That’s a very important but concealed question.
The answer is Nginx uses PCRE. Here is the link:
&lt;a href=&quot;http://stackoverflow.com/questions/14126872/what-regular-expression-engine-does-nginx-use&quot; title=&quot;what re&quot;&gt;What regular expression engine does Nginx use?&lt;/a&gt;&lt;/p&gt;

&lt;!---
### Reverse Proxy ###

try_file

upstream

proxy_pass

$uri
---&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;I have explained what is FastCGI and how to configure it in Nginx in this blog.&lt;/p&gt;

</description>
                <link>http://naizhengtan.github.io/2017/11/30/2015-7-24-web-nginx-fastcgi</link>
                <guid>http://naizhengtan.github.io/2017/11/30/2015-7-24-web-nginx-fastcgi</guid>
                <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        </item>

        <item>
                <title></title>
                <description>&lt;p&gt;Recently, I met a problem on deploying &lt;a href=&quot;http://www.read.seas.harvard.edu/~kohler/hotcrp/&quot; title=&quot;hotcrp&quot;&gt;HotCRP&lt;/a&gt; on Nginx+HHVM.
It seems that Nginx cannot redirect the URI correctly to HotCRP.
During the trouble shooting process, I was really annoying by the 
Nginx’s configuration and simple-but-not-complete blogs online.
So I’ve decided to structurally learn and write down the Nginx
config staff.&lt;/p&gt;

&lt;p&gt;This is the first blog about basic Nginx Configuration.
The config file on Ubuntu14.04 will be in “/etc/nginx/nginx.conf”. 
If you don’t know where your config file is, 
you can use &lt;code&gt;nginx -t&lt;/code&gt; to check it out.&lt;/p&gt;

&lt;h3 id=&quot;command-to-control-nginx&quot;&gt;Command to control Nginx&lt;/h3&gt;

&lt;p&gt;I’m intended to skip the install or compiling/install procedure
since there are whole bunch of blogs talking about them.
You can either install them by package manager (apt-get/yum) or
download the source code and compile from scratch.&lt;/p&gt;

&lt;p&gt;When one uses Nginx by her first time, the reasonable questions she 
would ask might be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;How to control (start/stop/reload) the nginx server?&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Start&lt;/strong&gt; Nginx server:&lt;/p&gt;

    &lt;p&gt;(1) If you use whatever package manager to install the
  nginx, like apt-get or yum, you probably can use
  &lt;code&gt;service nginx start&lt;/code&gt; to start the nginx server.&lt;/p&gt;

    &lt;p&gt;(2) If you compile it from source code, you can run &lt;code&gt;nginx&lt;/code&gt; to
  start the server. Yet, please make sure you are using the correct
  and suitable configuration which use &lt;code&gt;nginx -h&lt;/code&gt; to know more.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;reload/stop&lt;/strong&gt; server:&lt;/p&gt;

    &lt;p&gt;Use cmd &lt;code&gt;nginx -s [quit|stop|reload]&lt;/code&gt; to [graceful stop|quick stop|reload]
  the server.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;How do I know the Nginx server works?&lt;/p&gt;

    &lt;p&gt;Run &lt;code&gt;ps aux|grep hhvm&lt;/code&gt; to see if there is any process named nginx.
  If it works fine, you shoud see something similar like:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  root     17171  0.0  0.0  85996  2424 ?        Ss   09:40   0:00 nginx: master process /usr/sbin/nginx
  www-data 29013  0.0  0.0  86280  1924 ?        S    22:24   0:00 nginx: worker process
  www-data 29014  0.0  0.0  86280  1924 ?        S    22:24   0:00 nginx: worker process
  www-data 29015  0.0  0.0  86280  2180 ?        S    22:24   0:00 nginx: worker process
  www-data 29016  0.0  0.0  86280  1924 ?        S    22:24   0:00 nginx: worker process
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;basic-layout-of-nginx&quot;&gt;Basic Layout of Nginx&lt;/h3&gt;

&lt;p&gt;The config file of Nginx is quite clear.
It will have similar layout as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(1)
events {
  (2)
}
http {
  (3)
  server {
    (4)
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have divided the config file into 4 sections, namely (1)-(4)
on the above code.
In each section, there will be a bunch of directives 
which can fit in. I will follow this four sections
to introduce the directives. &lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html&quot; title=&quot;list of directives&quot;&gt;Here&lt;/a&gt; is
a list of core directives.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: There are not only these four sections which you
can write directives, and the layout is not fixed like above.
For example, you can have multiple &lt;code&gt;server{}&lt;/code&gt; in
one &lt;code&gt;http{}&lt;/code&gt; context. Also, there are more blocks,
such as &lt;code&gt;mail{}&lt;/code&gt; which I didn’t mention here. What
I have demonstrated is just a simple but general case.&lt;/p&gt;

&lt;h3 id=&quot;section1-directives-for-the-main-context&quot;&gt;Section(1): Directives for the Main Context&lt;/h3&gt;

&lt;p&gt;Each of the &lt;code&gt;&amp;lt;name&amp;gt; {...}&lt;/code&gt; like structure is called context. 
In each context, there will be different directives which can take effect.
However, in setction(1), out of all other context, we call it main context.
Here are some directives can place here:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#user&quot; title=&quot;user&quot;&gt;user&lt;/a&gt;&lt;/strong&gt;: Directive “user” can take two parameters which are user name
and group name the nginx is running on behalf of.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user www-data www-data

events {
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will run Nginx on behalf of user www-data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_processes&quot; title=&quot;worker processes&quot;&gt;worker_processes&lt;/a&gt;&lt;/strong&gt;: Given by a number, this directive will
set the number of worker processes the nginx will issue. The
following means there will be four worker processes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
worker_processes 4;

events {
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section2-event-context&quot;&gt;Section(2): Event Context&lt;/h3&gt;

&lt;p&gt;Nginx is an event-driven server.
The event context includes some configurations about the
event handling. For example, how many connections for a
worker process (&lt;a href=&quot;http://nginx.org/en/docs/ngx_core_module.html#worker_connections&quot; title=&quot;worker connections&quot;&gt;worker_connections&lt;/a&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
events {
  worker_connections 512;
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section3-http-context&quot;&gt;Section(3): HTTP Context&lt;/h3&gt;

&lt;p&gt;Http context contains the server context which will be discussed
in the next section. The server context represents a “server” which
will responds user’s requests. There can multiple server context 
inside http context, and there is only one http context.&lt;/p&gt;

&lt;p&gt;Somehow, the drectives placed in Section(3) can be regarded as
the common directives shared by all the server contexts.
You can put everything into different server contexts.
But the best practice would be put the shared directives here.&lt;/p&gt;

&lt;h3 id=&quot;section4-server-context&quot;&gt;Section(4): Server Context&lt;/h3&gt;

&lt;p&gt;This is the most important context you should take care of.
Server context will represent a http server which should respond to
the user’s requests.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot; title=&quot;listen directive&quot;&gt;listen&lt;/a&gt;&lt;/strong&gt;: The full explanation of this directive is &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#listen&quot; title=&quot;listen directive&quot;&gt;here&lt;/a&gt;.
It can be really complicated.
Directive listen tell Nginx which port is this “server” listen on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
  listen *:80
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default value for this directive is &lt;code&gt;listen *:80&lt;/code&gt;.
In other words, if you config a server context without listen directive,
then it will listen on port 80.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#root&quot; title=&quot;root&quot;&gt;root&lt;/a&gt;&lt;/strong&gt;: Sets the root directory for requests.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
  root /usr/share/nginx/html/
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, the root of this server would be “/usr/share/nginx/html/”.
The file “/usr/share/nginx/html/index.html” will be sent in response to the
“/index.html” request.
A path to the file is constructed by merely adding a URI to the value of the root directive.
If a URI has to be modified, the alias directive should be used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#location&quot; title=&quot;location&quot;&gt;location&lt;/a&gt;{…}&lt;/strong&gt;:
This is a context which belongs to serve context.
And this is also very important context.
Please see next section for more details.&lt;/p&gt;

&lt;h3 id=&quot;location-context&quot;&gt;Location Context&lt;/h3&gt;

&lt;p&gt;After previous configuration, the uri must match the
directory/filesystem layout of the root. However, sometime,
we want to put different resources into different place.
For instance, I may want uri “www.you.com/pic/good.jpg” goes to 
folder “~/picture/good.jpg”, while “www.you.com/index.html” is
still in “/usr/share/nginx/html/index.html”.&lt;/p&gt;

&lt;p&gt;The location context is used to mapping different uri to
different locations. The syntax of location context is like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location [=|~|~*|^~] uri {
  configuration_directives
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are four kinds of location context:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Prefix location&lt;/li&gt;
  &lt;li&gt;Exact location&lt;/li&gt;
  &lt;li&gt;Regular expression location&lt;/li&gt;
  &lt;li&gt;Non-Regular expression location&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Prefix location&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /pic/ {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Exact location&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location = /whatever/path/lol.jpg {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Regular expression location&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ \.(gif|jpg)$ {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that “~” means case-sensitive matching, which “xxx.gif” will match
but “xxx.GIF” won’t. On the contrary, “~*” is the indicator you want to
match case-insensitive matching.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Non-Regular expression location&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ^~ /whatever/path/ {
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;!---
Named location:

	location @what {
		...
	}
	
	location /why/ {
		try_file why.html @what;
	}
---&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#alias&quot; title=&quot;alias&quot;&gt;alias&lt;/a&gt;&lt;/strong&gt;: Directive “alias” is a little bit different from “root”.
The “root” will still contain the matching path as suffix; while
“alias” totally replace it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location /whatever/ {
	root /new/path/to/;
}

location /whatever2/ {
	alias /new/path/to/;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of these two location would be:&lt;br /&gt;
&lt;code&gt;www.you.com/whaterever/ =&amp;gt; /new/path/to/whatever/&lt;/code&gt;&lt;br /&gt;
and&lt;br /&gt;
&lt;code&gt;www.you.com/whatever2/ =&amp;gt; /new/path/to/&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;the-location-block-selection-algorithm&quot;&gt;The Location Block Selection Algorithm&lt;/h3&gt;

&lt;p&gt;This section is borrowed from book &lt;a href=&quot;https://www.nginx.com/oreilly-guide&quot; title=&quot;nginx book&quot;&gt;Nginx: A Practical Guide&lt;/a&gt;.
And it is talking about which location to use if Nginx has several
matching locations.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Modifier&lt;/th&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;(none)&lt;/td&gt;
      &lt;td&gt;Prefix&lt;/td&gt;
      &lt;td&gt;Matches on the prefix of a URI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;=&lt;/td&gt;
      &lt;td&gt;Exact Match&lt;/td&gt;
      &lt;td&gt;Matches an exact URI&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;~/~*&lt;/td&gt;
      &lt;td&gt;Regular Expression&lt;/td&gt;
      &lt;td&gt;Matches a URI against a case-sensitive/insensitive regular expression&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;^~&lt;/td&gt;
      &lt;td&gt;Non-regular expression prefix&lt;/td&gt;
      &lt;td&gt;Matches a URI against a prefix and skips regular expression matching&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The algorithm of the Nginx location matching:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The exact match location blocks are checked.
If an exact match is found, the search is terminated and the location block is used.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All of the prefix location blocks are checked for the
most specific (longest) matching prefix. If the best match has
the ^~ modifier, the search is terminated and the block is used.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Each regular expression block is checked in sequential order.
If a regular expression match occurs, the search is terminated and block is used.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If no regular expression block is matched, the best prefix
location block determined in step #2 is used.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To summary, we talked about the basic control commands of Nginx,
and the layout of Nginx’s config file.
By splitting the file into 4 sections, we have introduced
4 different context as well as several directives on each 
context. At last, we talked about location context which belongs
to server context and Nginx’s location matching algorithm.&lt;/p&gt;

</description>
                <link>http://naizhengtan.github.io/2017/11/30/2015-7-22-web-nginx-config-I</link>
                <guid>http://naizhengtan.github.io/2017/11/30/2015-7-22-web-nginx-config-I</guid>
                <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        </item>

        <item>
                <title></title>
                <description>&lt;p&gt;This series of blogs are designed to explore the inner implementation and desgin of 
&lt;a href=&quot;hhvm.com&quot;&gt;hhvm&lt;/a&gt;, a PHP interpreter developed by Facebook. There are a set of topics
should be covered, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-15-inside-hhvm-value-system&quot; title=&quot;value system&quot;&gt;Value systems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-18-inside-hhvm-main-loop&quot; title=&quot;main loop&quot;&gt;Interpreter Architecture I: Main Loop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Interpreter Architecture II: Stack&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Builtin Functions&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;HHVM bytecode&lt;/li&gt;
  &lt;li&gt;Jit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HHVM is still in rapid developing, and the version I am working on is 3.6.0.
However, I believe the main design and implementation would remain the same.&lt;/p&gt;

&lt;h3 id=&quot;inside-hhvm-builtin-functions&quot;&gt;Inside HHVM: Builtin Functions&lt;/h3&gt;

&lt;p&gt;One reason that PHP becomes one of the most popular language in the world is
that it provides a lot of builtin functions which are really convenient
for developers. What I called “builtin functions” here is the function defined
by PHP itself rather than the developers, for example, “file_exists”, “fgetcsv”
and so on.&lt;/p&gt;

&lt;p&gt;Today our topic is the design and implementation of PHP builtin functions in HHVM.
This can be a very complicated subject. I will only give the big picture
and some important implementation details here.&lt;/p&gt;

&lt;p&gt;By thinking how the builtin functions works, the following questions would be
the points interested us:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;What happens when invoking a builtin function?&lt;/li&gt;
  &lt;li&gt;Where is the implementation of builtin functions?&lt;/li&gt;
  &lt;li&gt;How does the system link the function name and implementation?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s see these questions one by one.&lt;/p&gt;

&lt;h3 id=&quot;invoke-builtin-function&quot;&gt;Invoke Builtin Function&lt;/h3&gt;

&lt;p&gt;For one PHP scripts, you can use &lt;code&gt;hhvm -vEval.Hhas=true your.php&lt;/code&gt; to covert
PHP code into bytecodes where “your.php” is the PHP script you want to convert.
So, first, let’s see what’s the corresponding opcode/bytecode for invoking
builtin functions.&lt;/p&gt;

&lt;p&gt;Suppose we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php 
functions_exists(&quot;abs&quot;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the conversion, we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String &quot;abc&quot;
True
FCallBuiltin 2 1 &quot;function_exists&quot;
UnboxRNop
PopC
Int 1
RetC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, the opcode &lt;strong&gt;FCallBuiltin&lt;/strong&gt; taken three parameter
“2”, “1” and “function_exists” would be the key point of invoking
builtin functions. 
The first parameter of &lt;strong&gt;FCallBuiltin&lt;/strong&gt; represents the number of arguments
this builtin function could take; The second parameter indicates the actual
number of non default arguments; And the final string is apparently the name of
the builtin function.&lt;/p&gt;

&lt;p&gt;The implementation of opcode &lt;strong&gt;FCallBuiltin&lt;/strong&gt; is in file 
&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/bytecode.cpp&quot; title=&quot;main loop&quot;&gt;runtime/vm/bytecode.cpp&lt;/a&gt;. Here is a simplified version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTBLD_INLINE void iopFCallBuiltin(IOP_ARGS) {
	pc++;
	// Get three parameters for FCallBuiltin
	auto numArgs = decode_iva(pc);
	auto numNonDefault = decode_iva(pc);
	auto id = decode&amp;lt;Id&amp;gt;(pc);

	// Search for the builtin function
	const NamedEntity* ne = vmfp()-&amp;gt;m_func-&amp;gt;unit()-&amp;gt;lookupNamedEntityId(id);
	Func* func = Unit::lookupFunc(ne);

	// Fetch the arguments
	TypedValue* args = vmStack().indTV(numArgs-1);

	// Invoke the builtin function
	TypedValue ret;
	Native::callFunc&amp;lt;true, false&amp;gt;(func, nullptr, args, ret);

	// Clean the invoking
	frame_free_args(args, numNonDefault);
	vmStack().ndiscard(numArgs);
	tvCopy(ret, *vmStack().allocTV());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are basically five steps to finish calling the builtin function:&lt;/p&gt;

&lt;p&gt;(1) &lt;strong&gt;Get three parameters for FCallBuiltin&lt;/strong&gt;: the variable “pc” here is 
program counter or instruction pointer which points to current executing instruction.
By given pc to decode_iva/decode, interpreter will know the number of
arguments and non default ones. In our example, numArgs will be 2, and
numNonDefault will be 1.&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;Search for the builtin function&lt;/strong&gt;: We encounter two new data structure here:
&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/named-entity.h&quot; title=&quot;namedentity&quot;&gt;NamedEntity&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/unit.h&quot; title=&quot;unit&quot;&gt;Unit&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NamedEntity represents a user-defined name that may map to 
different objects in different requests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unit is the metadata about a compilation unit which
Contains the list of PreClasses and global functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, what the two line code done here is:
First, query the unit of current function (&lt;code&gt;vmfp()-&amp;gt;m_func&lt;/code&gt;) and
figure out the &lt;strong&gt;NamedEntity&lt;/strong&gt; corresponding to the &lt;strong&gt;Id&lt;/strong&gt; provided as arguments
of &lt;strong&gt;FCallBuiltin&lt;/strong&gt; bytecode. Second, look up the function this &lt;strong&gt;NamedEntity&lt;/strong&gt;
represents. In short, we do the process &lt;code&gt;id -&amp;gt; NamedEntity -&amp;gt; Func&lt;/code&gt; and
at last find the function by the id.&lt;/p&gt;

&lt;p&gt;(3)&lt;strong&gt;Fetch the arguments&lt;/strong&gt;: This line of code is faily simple and self-explaning.
It assigns the “args” pointer to the stack position which is “numArgs” away from
top. Since all the arguments are pushed to stack and there are “numArgs” of them,
the invoking procedure just lets a pointer points to the first argument on stack.&lt;/p&gt;

&lt;p&gt;(4)&lt;strong&gt;Invoke the builtin function&lt;/strong&gt;: By using &lt;code&gt;Native::callFunc()&lt;/code&gt; function with
the builtin function we found and arguments pointer, the HHVM will invoke the
builtin function pointer feeding the given arguments. The detail of class &lt;strong&gt;Native&lt;/strong&gt;
is &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/native.cpp&quot; title=&quot;runtime/vm/native.cpp&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;(5)&lt;strong&gt;Clean the Invoking&lt;/strong&gt;: After the builtin function call, the interpreter
frees the arguments, pops the elements on stack and most importantly copies
the return value to the top of the stack.&lt;/p&gt;

&lt;h3 id=&quot;builtin-function-implementation&quot;&gt;Builtin Function Implementation&lt;/h3&gt;

&lt;p&gt;Usually, the builtin functions are implemented in folder “hphp/runtime/ext”.
Let’s take the above “function_exists” as an example. It is located in
file “hphp/runtime/ext/ext_std_function.cpp”.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; bool HHVM_FUNCTION(function_exists, const String&amp;amp; function_name,
                     bool autoload /* = true */) {
  return
    function_exists(function_name) ||
    (autoload &amp;amp;&amp;amp;
     AutoloadHandler::s_instance-&amp;gt;autoloadFunc(function_name.get()) &amp;amp;&amp;amp;
     function_exists(function_name));
  	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HHVM_FUNCTION&lt;/code&gt; here is a macro which is used to define the pattern of
builtin function’s name. The macro’s content is the following which is
defined in the file &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/native.h&quot; title=&quot;hphp/runtime/vm/native.h&quot;&gt;hphp/runtime/vm/native.h&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define HHVM_FUNCTION(fn, ...) \
        HHVM_FN(fn)(__VA_ARGS__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;HHVM_FN&lt;/code&gt; is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define HHVM_FN(fn) f_ ## fn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To simulate a preprocessor, we can expand the macro and the origin code
would become:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool f_function_exists(const String&amp;amp; function_name, bool autoload) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this function is the real takeing effect function when the bytecode 
&lt;code&gt;FCallBuiltin 2 1 &quot;function_exists&quot;&lt;/code&gt; is executing.&lt;/p&gt;

&lt;h3 id=&quot;link-function-name-and-implementation&quot;&gt;Link Function Name and Implementation&lt;/h3&gt;

&lt;p&gt;The last question would be: how the system links the function name
(i.e. “function_exists”) to its real implementation (i.e. &lt;code&gt;f_function_exists(...)&lt;/code&gt;)?&lt;/p&gt;

&lt;p&gt;First, let me give a brief overview of how it works. During the initialization
of the interpreter, the buitin function implementations will register themselves
to a global table. During the execution, when &lt;code&gt;FCallBuiltin&lt;/code&gt; bytecode is executing,
interpreter will check the global table indexing by the name given by FCallBuiltin,
and get the implementation’s function pointer. With such function pointer and the
arguments, the function will be called.&lt;/p&gt;

&lt;p&gt;Here is how “function_exists” register itself to the system. The function
&lt;code&gt;void StandardExtension::initFunction()&lt;/code&gt; in &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/ext/std/ext_std_function.cpp&quot; title=&quot;/runtime/ext/std/ext_std_function.cpp&quot;&gt;hphp/runtime/ext/std/ext_std_function.cpp&lt;/a&gt;
is responds for registering builtin functions. We can see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void StandardExtension::initFunction() {
  ...
  HHVM_FE(function_exists); 
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HHVM_FE&lt;/code&gt; is still a macro defined &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/native.h&quot; title=&quot;hphp/runtime/vm/native.h&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define HHVM_NAMED_FE(fn, fimpl) \
      Native::registerBuiltinFunction(#fn, fimpl)
#define HHVM_FE(fn) HHVM_NAMED_FE(fn, HHVM_FN(fn))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After unfolding the macro, &lt;code&gt;HHVM_FE(function_exists);&lt;/code&gt; will become:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Native::registerBuiltinFunction(&quot;function_exists&quot;, f_function_exists);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It calls the registerBuiltinFunction with the function name
“function_exists” and its real implementation &lt;code&gt;f_function_exists(...)&lt;/code&gt;.
Let’s see how they are linked together:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;class Fun&amp;gt;
inline void registerBuiltinFunction(const char* name, Fun func) {
   s_builtinFunctions[makeStaticString(name)] = (BuiltinFunction)func;
 } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a simplified version, full version is &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/native.h&quot; title=&quot;hphp/runtime/vm/native.h&quot;&gt;here&lt;/a&gt;.
Apparently, &lt;code&gt;s_builtinFunctions&lt;/code&gt; is the global table whoes index is the
function’s name and the value is the function pointer or the builtin function’s
implementation.&lt;/p&gt;

&lt;h3 id=&quot;bloody-details&quot;&gt;Bloody Details&lt;/h3&gt;

&lt;p&gt;There are some bloody details about:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;How the NamedEntity filled with function?&lt;/li&gt;
  &lt;li&gt;How to invoke the function?&lt;/li&gt;
  &lt;li&gt;How to add a new builtin function?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) &lt;strong&gt;How the NamedEntity filled with function&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;UNKNOWN&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;(2) &lt;strong&gt;How to invoke the function&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;template&amp;lt;bool usesDoubles, bool variadic&amp;gt; 
void callFunc(const Func* func, void *ctx,
TypedValue *args, TypedValue&amp;amp; ret)&lt;/code&gt; in native.cpp&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;callFuncInt64Impl(...)&lt;/code&gt; in native-function-caller.h&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(3) &lt;strong&gt;How to add a new buitin function&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;UNKOWN&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To summary, We have introduced three main topics about buitin function: 
(1) how to invoke the builtin function; (2) where is its implementaion;
and (3) how the name and its implementation linked.&lt;/p&gt;

</description>
                <link>http://naizhengtan.github.io/2017/11/30/2015-7-21-inside-hhvm-builtin-function</link>
                <guid>http://naizhengtan.github.io/2017/11/30/2015-7-21-inside-hhvm-builtin-function</guid>
                <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        </item>

        <item>
                <title></title>
                <description>&lt;p&gt;This series of blogs are designed to explore the inner implementation and desgin of 
&lt;a href=&quot;hhvm.com&quot;&gt;hhvm&lt;/a&gt;, a PHP interpreter developed by Facebook. There are a set of topics
should be covered, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2017/11/30/2015-7-15-inside-hhvm-value-system&quot; title=&quot;value system&quot;&gt;Value systems&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Interpreter Architecture I: Main Loop&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;HHVM bytecode&lt;/li&gt;
  &lt;li&gt;Jit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HHVM is still in rapid developing, and the version I am working on is 3.6.0.
However, I believe the main design and implementation would remain the same.&lt;/p&gt;

&lt;h3 id=&quot;inside-hhvm-main-loop&quot;&gt;Inside HHVM: Main Loop&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Program = Data Structures + Alogirthms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In &lt;a href=&quot;/2017/11/30/2015-7-15-inside-hhvm-value-system&quot; title=&quot;value system&quot;&gt;HHVM value system&lt;/a&gt;, we know what data structures are used to store different types
of value. In this charpter, “algorithm” of the interpreter become our topic.
In short, HHVM simulates what CPU does. It fetches the current instruction, executes it, updates
the states and fetches the next instruction, so on and so forth. I personally call this
fetch-execute-fetch procedure the “&lt;strong&gt;Main Loop&lt;/strong&gt;”.&lt;/p&gt;

&lt;h3 id=&quot;hiphop-bytecode&quot;&gt;HipHop Bytecode&lt;/h3&gt;

&lt;p&gt;Like CPU, HHVM has its own ISA which called HipHop Bytecode.
When HHVM tries to execute a PHP script, it first translates the PHP source code to
an intermediate representation which called HHBC (HipHop bytecode), then execute the bytecode
line by line. The HHBC is very much like Java bytecode. You can check the detailed 
design and its semantics &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/doc/bytecode.specification&quot; title=&quot;bytecode spec&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HipHop bytecode (HHBC) v1 is intended to serve as the conceptual basis for
encoding the semantic meaning of HipHop source code into a format that is
appropriate for consumption by interpreters and just-in-time compilers. By
using simpler constructs to encode more complex expressions and statements,
HHBC makes it straightforward for an interpreter or a compiler to determine
the order of execution for a program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s take the naivest “hello world” program as an example. Suppose we have a hello-world
PHP program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
  $a = &quot;hello world&quot;;
  echo $a;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can imagine this snippet of PHP code will be “compiled” to a series of HipHop bytecode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String &quot;hello world&quot;
SetL $a
PopC
CGetL $a
Print
PopC
Int 1
RetC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each line of bytecode will be one instruction fetched and executed by HHVM interpreter.&lt;/p&gt;

&lt;h3 id=&quot;abstract-architecture-of-interpreter&quot;&gt;Abstract Architecture of Interpreter&lt;/h3&gt;

&lt;p&gt;The abstract architecture of interpreter is fairly simple.
It can be a big loop like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(;;) {
	ins = fetch(); // fetch the new instrucction
	
	switch(ins) {  // jump to the right instruction
		case String: ...
		case SetL: ...
		case PopC: ...
		...
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The logic of “Main Loop” is just like described above.
Each time the interpreter fetches a instruction, it check what
the instruction is and jump to the corresponding instruction function.
After execution, it will do the fetching again until meet the EXIT instruction
or reach the end of the program. In the following paragraphs, I will use
instruction and bytecode interchangeably.&lt;/p&gt;

&lt;h3 id=&quot;hhvm-main-loop&quot;&gt;HHVM Main Loop&lt;/h3&gt;

&lt;p&gt;Sharing the same logic with our abstract architecure discribed in last section,
HHVM uses a different way to implement fetch-execute-fetch procedure. It adds
the “fetch and switch” operation to the end of each instruction function.
Instruction function is the function which implements what the bytecode,
say SetL/Popc, should do.&lt;/p&gt;

&lt;p&gt;The pesudocode of the design is like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jumpTab[] = {
	iopString,
	iopSetL,
	iopPopC,
};

void fetchAndJump() {
	ins = fetch();
	jumpTab[ins]();
}

void iopString() {... fetchAndJump();}
void iopSetL()   {... fetchAndJump();}
void iopPopC()   {... fetchAndJump();}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the interpreter finishes one instruction execution, say “SetL”, which should
be running “iopSetL()”, it will called “fetchAndJump()”. And the “fetchAndJump()”
will continue the program by jummping to the next instruction function.&lt;/p&gt;

&lt;p&gt;In order to implement such design, we need to three components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Jumping table&lt;/li&gt;
  &lt;li&gt;Fetch and jump function&lt;/li&gt;
  &lt;li&gt;Instruction functions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jumping-table&quot;&gt;Jumping Table&lt;/h3&gt;

&lt;p&gt;In order to implement the design, HHVM first define a function table which
contains all the instruction functions HHVM supports. HHVM uses the macro to
generate such table in &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/bytecode.cpp&quot; title=&quot;main loop&quot;&gt;runtime/vm/bytecode.cpp&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const void *optabDirect[] = {
	#define O(name, imm, push, pop, flags) \
	&amp;amp;&amp;amp;Label##name,
	OPCODES
	#undef O
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be little tricky to understand the code by first sight.
The “OPCODES” above is a macro declared in &lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/hhbc.h&quot; title=&quot;hhbc&quot;&gt;runtime/vm/hhbc.h&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//  name             immediates        inputs           outputs     flags
 	#define OPCODES \
   ...
   O(PopC,            NA,               ONE(CV),         NOV,        NF) \
   ...
   O(String,          ONE(SA),          NOV,             ONE(CV),    NF) \
   ...
   O(SetL,            ONE(LA),          ONE(CV),         ONE(CV),    NF) \
   ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, after the preprocessor, 
the the “opttabDirect” will be expanded as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static const void *optabDirect[] = {
	...
	&amp;amp;&amp;amp;LabelPopC,
	...
	&amp;amp;&amp;amp;LabelString,
	...
	&amp;amp;&amp;amp;LabelSetL,
	...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this table, HHVM can use &lt;code&gt;goto *optab[uint8_t(op)]&lt;/code&gt; (“op” is the instruction
number) jumping to the instruction function very efficiently.&lt;/p&gt;

&lt;h3 id=&quot;fetch-and-jump-function&quot;&gt;Fetch and Jump Function&lt;/h3&gt;

&lt;p&gt;The “fetch and jump” function is also a macro in HHVM called “DISPATCH”. This
is the simplified version. If you want to see the original one please check
&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/bytecode.cpp&quot; title=&quot;main loop&quot;&gt;runtime/vm/bytecode.cpp&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define DISPATCH() do {                      \
	Op op = *reinterpret_cast&amp;lt;const Op*&amp;gt;(pc); \
	goto *optab[uint8_t(op)];                 \
} while(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;instruction-functions&quot;&gt;Instruction Functions&lt;/h3&gt;

&lt;p&gt;The real implementation of each instruction is defined in the 
corresponding function named “iop&lt;bytecode-name&gt;&quot;. For example,
for instruction/bytecode &quot;PopC&quot;, the corresponding function is
&quot;iopPopC&quot;.&lt;/bytecode-name&gt;&lt;/p&gt;

&lt;p&gt;However, if you read the section &lt;a href=&quot;#jumping-table&quot;&gt;Jumping Table&lt;/a&gt; really carefully,
you will find that the jumping table contains a series of labels rather
than function pointers. HHVM needs somehow adding the labels to the
corresponding instruction functions. Here is the snippet of code
to do such work. Still they are macro. There are several good reasons
to use “lable + macro” rather than “function pointer” table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define O(name, imm, push, pop, flags)  \
	Label##name: {                       \
		iop##name(pc);                    \
		vmpc() = pc;                      \
		DISPATCH();                       \
	}
	OPCODES
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As usual, this is a simplified version, you can check the full version
&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/vm/bytecode.cpp&quot; title=&quot;main loop&quot;&gt;here&lt;/a&gt;. To recall, “OPCODES” is a macro we mentioned in section 
&lt;a href=&quot;#jumping-table&quot;&gt;Jumping Table&lt;/a&gt;; macro “DISPATCH” is a macro we mentioned 
in section &lt;a href=&quot;#fetch-and-jump-function&quot;&gt;Fetch and Jump Function&lt;/a&gt;.
This macro will build a series of labels each of which will (1) call
instruction function (2) call fetch-and-jump function.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To conclude, we have discussed the main logic of the interpreter and given a
detail analysis on the implementaion of HHVM’s “Main Loop”.&lt;/p&gt;

</description>
                <link>http://naizhengtan.github.io/2017/11/30/2015-7-18-inside-hhvm-main-loop</link>
                <guid>http://naizhengtan.github.io/2017/11/30/2015-7-18-inside-hhvm-main-loop</guid>
                <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        </item>

        <item>
                <title></title>
                <description>&lt;p&gt;This series of blogs are designed to explore the inner implementation and desgin of 
&lt;a href=&quot;hhvm.com&quot;&gt;hhvm&lt;/a&gt;, a PHP interpreter developed by Facebook. There are a set of topics
should be covered, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Value systems&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Interpreter Architecture&lt;/li&gt;
  &lt;li&gt;HHVM bytecode&lt;/li&gt;
  &lt;li&gt;Jit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HHVM is still in rapid developing, and the version I am working on is 3.6.0.
However, I believe
the main design and implementation would remain the same.&lt;/p&gt;

&lt;h3 id=&quot;inside-hhvm-value-system&quot;&gt;Inside HHVM: Value System&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Program = Data Structures + Alogirthms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to understand how the HHVM works, we have to first understand how the data
or variable are stored inside the interpreter.
As we all know, PHP has a series of value types, such as integer, float, string and so on.
What’s their data structures and how HHVM organizes them will be our first topic.&lt;/p&gt;

&lt;h3 id=&quot;php-basic-types&quot;&gt;PHP Basic Types&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://php.net/manual/en/language.types.intro.php&quot; title=&quot;php type&quot;&gt;PHP types&lt;/a&gt; include four
scalar types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;boolean&lt;/li&gt;
  &lt;li&gt;integer&lt;/li&gt;
  &lt;li&gt;float&lt;/li&gt;
  &lt;li&gt;string&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two compound types:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;array&lt;/li&gt;
  &lt;li&gt;object&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two special types&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;resource&lt;/li&gt;
  &lt;li&gt;NULL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, the types are kind of self-explaining. If you want to know more, please
check &lt;a href=&quot;http://php.net/manual/en/language.types.intro.php&quot; title=&quot;php type&quot;&gt;PHP types&lt;/a&gt; or other references.&lt;/p&gt;

&lt;h3 id=&quot;hhvm-value-data-structures&quot;&gt;HHVM Value Data Structures&lt;/h3&gt;

&lt;p&gt;PHP types are defined in header file typed-value.h
(&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/typed-value.h&quot; title=&quot;type value&quot;&gt;hphp/runtime/base/typed-value.h&lt;/a&gt;).
For one value the base struct is TypedValue whose definition is:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TypedValue&lt;/strong&gt; (&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/typed-value.h&quot; title=&quot;type value&quot;&gt;hphp/runtime/base/typed-value.h&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct TypedValue {
	Value m_data;
	DataType m_type;
	AuxUnion m_aux;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;A TypedValue is a descriminated PHP Value. m_tag describes the contents
of m_data.  m_aux must only be read or written
in specialized contexts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The definition is clear. m_data is where real data have been stored; m_type tells
HHVM how to interpret the m_data. m_aux is for auxiliary usage which I probably will
not describe here. Following the m_type, let us first see what “DataType” structure looks like.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DataType&lt;/strong&gt; (&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/datatype.h&quot; title=&quot;data type&quot;&gt;hphp/runtime/base/datatype.h&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum DataType : int8_t {
	// Values below zero are not PHP values, but runtime-internal.
	KindOfClass         = -13,

	// Any code that static_asserts about the value of KindOfNull may also depend
	// on there not being any values between KindOfUninit and KindOfNull.

	//      uncounted init bit
	//      |string bit
	//      ||
	KindOfUninit        = 0x00,  //  00000000
	KindOfNull          = 0x08,  //  00001000
	KindOfBoolean       = 0x09,  //  00001001
	KindOfInt64         = 0x0a,  //  00001010
	KindOfDouble        = 0x0b,  //  00001011
	KindOfStaticString  = 0x0c,  //  00001100
	KindOfString        = 0x14,  //  00010100
	KindOfArray         = 0x20,  //  00100000
	KindOfObject        = 0x30,  //  00110000
	KindOfResource      = 0x40,  //  01000000
	KindOfRef           = 0x50,  //  01010000
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;DataType is the type tag for a TypedValue (see typed-value.h).&lt;/p&gt;

  &lt;p&gt;Beware if you change the order, as we may have a few type checks in the code
 that depend on the order.  Also beware of adding to the number of bits
 needed to represent this.  (Known dependency in unwind-x64.h.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The definition of DataType declares all the types (eight of them) we know
from the previous PHP type introductions: &lt;strong&gt;bool/int/double/string/array/object/resource/Null&lt;/strong&gt;.
And more, we can see &lt;strong&gt;class&lt;/strong&gt; which has already mentioned in code commons as runtime-internal type;
As well as, &lt;strong&gt;uninit/staticString/Ref&lt;/strong&gt;, which we will see later when we discuss the bytecode of HHVM
and the internal logic of HHVM.&lt;/p&gt;

&lt;p&gt;After knowing what the type of this value, the next step is to know what is the value.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Value&lt;/strong&gt; (&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/typed-value.h&quot; title=&quot;type value&quot;&gt;hphp/runtime/base/typed-value.h&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;union Value {
	int64_t       num;    // KindOfInt64, KindOfBool (must be zero-extended)
	double        dbl;    // KindOfDouble
	StringData*   pstr;   // KindOfString, KindOfStaticString
	ArrayData*    parr;   // KindOfArray
	ObjectData*   pobj;   // KindOfObject
	ResourceData* pres;   // KindOfResource
	Class*        pcls;   // only in vm stack, no type tag.
	RefData*      pref;   // KindOfRef
};
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is the payload of a PHP value. This union may only be used in
contexts that have a discriminator, e.g. in TypedValue, or
when the type is known beforehand.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The description above is pretty clear for the union Value. Based on the type of the value, this structure/union
can be translated to different types. The &lt;strong&gt;int&lt;/strong&gt; and &lt;strong&gt;double&lt;/strong&gt; are fundamental type in C++. While others
are newly defined structures, such as &lt;strong&gt;string&lt;/strong&gt; will be a pointer to a structure called StringData.&lt;/p&gt;

&lt;p&gt;The newly defined data structures are:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;PHP type&lt;/th&gt;
      &lt;th&gt;HHVM structure&lt;/th&gt;
      &lt;th&gt;defined file&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;StringData&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/string-data.h&quot; title=&quot;string data&quot;&gt;runtime/base/string-data.h&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;array&lt;/td&gt;
      &lt;td&gt;ArrayData&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/array-data.h&quot; title=&quot;array data&quot;&gt;runtime/base/array-data.h&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;ObjectData&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/object-data.h&quot; title=&quot;object data&quot;&gt;runtime/base/object-data.h&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;resource&lt;/td&gt;
      &lt;td&gt;ResourceData&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/facebook/hhvm/blob/master/hphp/runtime/base/resource-data.h&quot; title=&quot;res data&quot;&gt;runtime/base/resource-data.h&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;

&lt;p&gt;To conclude, we review the type system in PHP which has eight different types and 
explore their detailed implementation inside HHVM interpreter. To be more specific,
one value of any type will be a “TypedValue”, within which are field “m_type” indicating the type
of such value and field “m_data” containing the real data payload. Except for fundamental
types like int/double/boolean, other types have HHVM’s own implementation in different files 
(see table for more information).&lt;/p&gt;

</description>
                <link>http://naizhengtan.github.io/2017/11/30/2015-7-15-inside-hhvm-value-system</link>
                <guid>http://naizhengtan.github.io/2017/11/30/2015-7-15-inside-hhvm-value-system</guid>
                <pubDate>2017-11-30T20:37:43-05:00</pubDate>
        </item>


</channel>
</rss>
